from .Model import Model
from google.cloud import datastore
import os
from datetime import date, datetime
import requests as r

KIND = 'TripDocs'
PROJECT = 'cloud-f21-robin-su-robisu'
NYT_KEY = os.environ.get('NYT_KEY')
NYT_BASE_URL = f'https://api.nytimes.com/svc/search/v2/articlesearch.json?api-key={NYT_KEY}'
WEATHER_KEY = os.environ.get('WEATHER_KEY')
WEATHER_BASE_URL = f'http://api.openweathermap.org/'

class model(Model):
    def __init__(self):
        """
        Initialize model object by creating client to interact with Google Datastore
        """
        self.client = datastore.Client(PROJECT)

    def select(self):
        """
        Query for all entities listed under the same KIND
        """
        query_kind = self.client.query(kind=KIND)
        query_iter = query_kind.fetch()
        docs = []
        for item in query_iter:
            entry = dict(title=item['title'], start_date=item['start_date'], end_date=item['end_date'], city=item['city'], state=item['state'], country=item['country'], notes=item['notes'], id=item.key.id)
            docs.append(entry)
    
        return docs
        
    def select_one(self, id):
        """
        Get single entity based on key of the associated object
        :params id: Id is an integer automatically generated by Datastore and uniquely identifies a single entity
        """   
        key =self.client.key(KIND, int(id))
        item = self.client.get(key)
        entry = dict(title=item['title'], start_date=item['start_date'], end_date=item['end_date'], city=item['city'], state=item['state'], country=item['country'], notes=item['notes'], id=item.key.id)

        return entry
        

    def insert(self, trip_details):
        """
        Enter new entity into Datastore under the specified KIND
        :param trip_details: dictionary of trip title, date range, and location information
        """
        key = self.client.key(KIND)
        trip = datastore.Entity(key)
        trip.update(
            {
                'title': trip_details['title'],
                'start_date': trip_details['start_date'],
                'end_date': trip_details['end_date'],
                'city': trip_details['city'],
                'state': trip_details['state'],
                'country': trip_details['country'],
                'notes': trip_details['notes'],
            }
        )
        self.client.put(trip)

        return True
        

    def update(self, trip_details):
        """
        Updates existing entry in database, based on entry id.
        :param trip_details: dictionary of trip title, date range, location, and entry id
        """
        key = self.client.key(KIND, int(trip_details['id']))
        trip = datastore.Entity(key)
        trip.update(
            {
                'title': trip_details['title'],
                'start_date': trip_details['start_date'],
                'end_date': trip_details['end_date'],
                'city': trip_details['city'],
                'state': trip_details['state'],
                'country': trip_details['country'],
                'notes': trip_details['notes'],
            }
        )
        self.client.put(trip)

        return True
    
    def get_article_data(self, loc_data):
        '''
        Query NYT API endpoint for relevant articles from the Travel section archives
        :param loc_data: city, state and country
        '''
        nyt_url = f'{NYT_BASE_URL}&q={loc_data["city"]},{loc_data["state"]},{loc_data["country"]}&fq=section_name:("Travel") AND glocations.contains:("{loc_data["city"]}" "{loc_data["country"]}")'
        response = r.get(nyt_url)
        response = response.json()
        
        if response['response']['docs'] == []:
            nyt_url = f'{NYT_BASE_URL}&q={loc_data["country"]}&fq=section_name:("Travel") AND glocations.contains:("{loc_data["country"]}")'
            response = r.get(nyt_url)
            response = response.json()

        assert response['status'] == 'OK', f'Received a non "OK" response: {response["status"]}'

        articles_list = [x for x in response['response']['docs']]
        links = []
        
        for a in articles_list:
            item = dict(headline=a['headline']['main'], url=a['web_url'], abstract=a['abstract'])
            pub = date.fromisoformat(a['pub_date'][:10])
            item['pub_date'] = f'{pub.month}/{pub.day}/{pub.year}'
            links.append(item)
        
        return links

    def get_weather_data(self, loc_data):
        '''
        Query OpenWeather API for 7-day forecast.
        :param loc_data: city, state and country
        '''
        geocode_url = f'{WEATHER_BASE_URL}geo/1.0/direct?q={loc_data["city"]},{loc_data["country"]}&limit=5&appid={WEATHER_KEY}'
        loc_resp = r.get(geocode_url)
        loc_resp = loc_resp.json()
        assert loc_resp != [], f'Received empty response from OpenWeatherAPI on location data'
        latitude = loc_resp[0]['lat']
        longitude = loc_resp[0]['lon']

        weather_url = f'{WEATHER_BASE_URL}data/2.5/onecall?lat={latitude}&lon={longitude}&units=imperial&exclude=current,minutely,hourly,alerts&appid={WEATHER_KEY}'
        response = r.get(weather_url)
        response = response.json()
        assert response != [], f'Received empty response from OpenWeatherAPI on forecast data: {response}'

        forecast = [] 
        for day in response['daily']:
            timestamp = datetime.fromtimestamp(day['dt'])
            dt = f'{timestamp.month}/{timestamp.day}'
            temp = day['temp']['day']
            desc = day['weather'][0]['description']
            icon = f'https://openweathermap.org/img/wn/{day["weather"][0]["icon"]}.png'
            forecast.append(dict(dt=dt, temp=temp, desc=desc, icon=icon))
        
        return forecast
